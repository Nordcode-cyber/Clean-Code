El principio Open/Closed (OCP) de SOLID dice:

Las clases deben estar abiertas a la extensi√≥n, pero cerradas a la modificaci√≥n.
O sea: cuando aparecen nuevos requerimientos, no deber√≠as modificar la clase existente, sino extenderla.
üîπ Problema real

Imaginemos que est√°s desarrollando un sistema de facturaci√≥n.
Tienes una clase que calcula impuestos:
```public class CalculadoraImpuestos {```
```public double calcular(double monto, String tipoImpuesto) { ```
        ```if (tipoImpuesto.equals("IVA")) {```
        ```return monto * 0.21; ```
        ``` } else if (tipoImpuesto.equals("GANANCIAS")) { ```
               ``` return monto * 0.35; ```
        ```} ```
        ```return 0; ```
       ``` } ```
```}```

Problema: Cada vez que aparece un nuevo impuesto (ej: ‚ÄúImpuesto Pa√≠s‚Äù), hay que modificar esta clase. Eso rompe OCP.

```public interface Impuesto { ```
```  double calcular(double monto);```
```} ```
```public class IVA implements Impuesto { ```
``` @Override```
```public double calcular(double monto) { ```
``` return monto * 0.21;```
   ```} ```
```} ```

```public class Ganancias implements Impuesto { ```
```   public double calcular(double monto) {```
```   return monto * 0.35;```
```  } ```
```} ```

*** Y si ma√±ana aparece un nuevo impuesto:
```public class ImpuestoPais implements Impuesto { ```
```   public double calcular(double monto) {```
```   return monto * 0.15;```
```  } ```
```} ```
üëâ No toco la CalculadoraImpuestos, solo extiendo con una nueva clase.
### üîπ Situaciones reales donde aplicar OCP

Pasarelas de pago (agregar PayPal, Stripe, MercadoPago sin modificar el c√≥digo existente).

Exportadores de reportes (PDF, Excel, CSV, JSON).

Sistemas de notificaci√≥n (email, SMS, push, WhatsApp).

Motores de reglas de negocio (descuentos seg√∫n temporada o cliente).


   



    
    
        
    



 


